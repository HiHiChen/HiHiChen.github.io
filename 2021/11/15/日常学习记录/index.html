<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="学习记录关于webpack weback是一个javascript的静态模块打包工具 webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子 最后输出由多个模块组合成的文件，webpack专注构建模块化项目  webpack的优点有啥 专注于处理模块化项目，能做到开箱即用，一步到位 通过plugin扩展，完整好用又不失灵活 通过loaedr扩展，可以让webpack把所">
<meta property="og:type" content="article">
<meta property="og:title" content="日常学习记录">
<meta property="og:url" content="http://example.com/2021/11/15/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="小陈的个人博客">
<meta property="og:description" content="学习记录关于webpack weback是一个javascript的静态模块打包工具 webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子 最后输出由多个模块组合成的文件，webpack专注构建模块化项目  webpack的优点有啥 专注于处理模块化项目，能做到开箱即用，一步到位 通过plugin扩展，完整好用又不失灵活 通过loaedr扩展，可以让webpack把所">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-15T03:05:18.000Z">
<meta property="article:modified_time" content="2021-12-05T11:58:03.095Z">
<meta property="article:author" content="小陈">
<meta property="article:tag" content="记录每天学习时的一些问题">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/11/15/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>日常学习记录 | 小陈的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小陈的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Record your school life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小陈">
      <meta itemprop="description" content="Study Record">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小陈的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          日常学习记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-15 11:05:18" itemprop="dateCreated datePublished" datetime="2021-11-15T11:05:18+08:00">2021-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-05 19:58:03" itemprop="dateModified" datetime="2021-12-05T19:58:03+08:00">2021-12-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%AF%8F%E6%97%A5%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">每日记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h2 id="关于webpack"><a href="#关于webpack" class="headerlink" title="关于webpack"></a>关于webpack</h2><ol>
<li>weback是一个javascript的静态模块打包工具</li>
<li>webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子</li>
<li>最后输出由多个模块组合成的文件，webpack专注构建模块化项目</li>
</ol>
<h3 id="webpack的优点有啥"><a href="#webpack的优点有啥" class="headerlink" title="webpack的优点有啥"></a>webpack的优点有啥</h3><ol>
<li>专注于处理模块化项目，能做到开箱即用，一步到位</li>
<li>通过plugin扩展，完整好用又不失灵活</li>
<li>通过loaedr扩展，可以让webpack把所有类型的文件都解析打包</li>
<li>区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展</li>
</ol>
<h3 id="webpack的构建流程是什么？"><a href="#webpack的构建流程是什么？" class="headerlink" title="webpack的构建流程是什么？"></a>webpack的构建流程是什么？</h3><p>webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：：</p>
<ol>
<li>初始化参数：从配置文件读取与合并参数，得出最终的参数</li>
<li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，开始执行编译</li>
<li>确定入口：根据配置文件中的 entry 找出所有的入口文件</li>
<li>编译模块：从入口文件出发，调用所有的配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，在递归本步骤直到所有入口都依赖的文件都经过了本步骤的处理</li>
<li>完成模块编译：在经过第4步使用 Loader 翻译完所有的模块后，得到了每个模块被翻译后最终内容以及它们之间的依赖关系</li>
<li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk, 再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ol>
<p>在以上过程中，webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 webpack 提供的 API 改变 webpack 的运行结果</p>
<h3 id="说一下-webpack-的热更新原理"><a href="#说一下-webpack-的热更新原理" class="headerlink" title="说一下 webpack 的热更新原理"></a>说一下 webpack 的热更新原理</h3><p>webpack的热更新又称热替换（Hot Module Replacement)，缩写为 HMR。这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</p>
<p>HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS(webpack-dev-server)与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构架时的 hash，让客户端与上一次资源进行比对。客户端对比出差异后会向 WDS 发送请求来获取更改的内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该 chunk 的增量更新。</p>
<p>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关的 API 以供开发者针对自身场景进行处理，像 react-hot-loader 和 vue-loader 都是借助这些 API 实现的 HMR。</p>
<h3 id="webpack与grunt、gulp的不同"><a href="#webpack与grunt、gulp的不同" class="headerlink" title="webpack与grunt、gulp的不同"></a>webpack与grunt、gulp的不同</h3><ul>
<li>三者之间的区别</li>
</ul>
<p>三者都是前端的工具，grunt和gulp在早期比较流行，现在webpoack 相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包css文件等。</p>
<p>grunt和gulp是基于任务和流（Task、Stream）的。类似于jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据，整条链式操作构成了 一个任务，多个任务就构成了整个web的构建流程。</p>
<p>webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。</p>
<ul>
<li>从构建思路来说</li>
</ul>
<p>gulp和grunt需要开发者将整个前端构建过程分成多个Task，并合理控制所有Task的调用关系webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工</p>
<ul>
<li>对知识背景来说</li>
</ul>
<p>gulip更像后端开发者的思路，需要对于整个流程了如指掌webpack更倾向于前端开发者的思路</p>
<h3 id="Loader和Plugin的不用"><a href="#Loader和Plugin的不用" class="headerlink" title="Loader和Plugin的不用"></a>Loader和Plugin的不用</h3><ul>
<li>不同的作用</li>
</ul>
<p>Loader直译为“加载器”。webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。所以loader的作用是让webpack拥有了加载和解析非javaScript文件的能力</p>
<p>Plugin直译为 “插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。在webpack运行的生命周期中会广播出许多事件，Plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出的结果</p>
<ul>
<li>不同的用法</li>
</ul>
<p>Loader在module.rules中配置，也就是说他作为模块的解析规则而存在。类型为数组，每一项都是Object，里面描述了对于什么类型的文件（test），使用什么加载（loader）和使用的参数（options）</p>
<p>Plugin在plugins中单独配置。类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入。</p>
<h2 id="关于Vue"><a href="#关于Vue" class="headerlink" title="关于Vue"></a>关于Vue</h2><h3 id="Vue的最大优势是什么？"><a href="#Vue的最大优势是什么？" class="headerlink" title="Vue的最大优势是什么？"></a>Vue的最大优势是什么？</h3><p>简单易学，轻量级整个源码js文件不大，双向数据绑定，数据驱动视图，组件化，数据和视图分离，</p>
<p>Vue负责关联视图和数据，作者中国人（尤雨溪），文档都是中文的，入门教程非常多，上手简单</p>
<p>相比传统网页，Vue是单页面可以只刷新某一部分</p>
<h3 id="Vue和jQuery的区别"><a href="#Vue和jQuery的区别" class="headerlink" title="Vue和jQuery的区别"></a>Vue和jQuery的区别</h3><p>jQuery应该算是一个插件，里面封装了各种易用的方法，方便你使用更少的代码来操作DOM标签</p>
<p>Vue是一套框架，有自己的规则和体系与语法，特别是设计思想MVVM，让数据和视频关联绑定，省略了很多DOM操作，然后指令还给标签注入更多的功能</p>
<h3 id="MVVM和MVC区别"><a href="#MVVM和MVC区别" class="headerlink" title="MVVM和MVC区别"></a>MVVM和MVC区别</h3><p>MVC：一种设计模式，组织代码的结构，是model数据模型，view视图，Controller控制器，在控制器这层里编写js代码，来控制数据和视图关联</p>
<p>MVVM：即Model-View-ViewModel的简写。即模型-视图-视图模型，VM是这个设计模式的核心，连接v和m的桥梁，内部会监听DOM事件，监听数据对象变化来影响对方，我们称之为数据绑定</p>
<h3 id="Vue2-x兼容IE哪些版本"><a href="#Vue2-x兼容IE哪些版本" class="headerlink" title="Vue2.x兼容IE哪些版本"></a>Vue2.x兼容IE哪些版本</h3><p>不支持ie8及以下，部分兼容ie9，完全兼容10以上，因为Vue的响应式原理是基于es5的Object.defineProperty()，而这个方法不支持ie8及以下</p>
<h3 id="对Vue渐进式的理解"><a href="#对Vue渐进式的理解" class="headerlink" title="对Vue渐进式的理解"></a>对Vue渐进式的理解</h3><p>渐进式代表的含义是：主张最少，自底向上，增量开发，组件集合，便于复用</p>
<h3 id="为什么避免v-for和v-if在一起使用"><a href="#为什么避免v-for和v-if在一起使用" class="headerlink" title="为什么避免v-for和v-if在一起使用"></a>为什么避免v-for和v-if在一起使用</h3><p>Vue处理指令时，v-for比v-if具有更高的优先级，虽然用起来也没报错，但是性能不高，如果你有5个元素被v-for循环，v-if也会分别执行5次</p>
<h3 id="Vue中-key作用，为什么不能用索引"><a href="#Vue中-key作用，为什么不能用索引" class="headerlink" title="Vue中:key作用，为什么不能用索引"></a>Vue中:key作用，为什么不能用索引</h3><p>:key是给v-for循环生成标签颁发的唯一标识，用于性能的优化</p>
<p>因为v-for数据项的顺序改变，Vue也不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素</p>
<p>:key如果是索引，因为索引是连续的，如果删掉其中某一个，会导致最后一个被删除</p>
<p>当我们在删除时，:key再根据数据来把新旧的dom对比时，删除:key不存在的对应的标签(添加也是一样的插入到指定位置，别的都不会动)</p>
<h3 id="数据更新有时候v-for不渲染"><a href="#数据更新有时候v-for不渲染" class="headerlink" title="数据更新有时候v-for不渲染"></a>数据更新有时候v-for不渲染</h3><p>因为vue内部只能监测到数组顺序/位置的改变/数量的改变，但是植被重新赋予监测不到变更，可以用Vue.set()/vm.$set()</p>
<h3 id="封装Vue组件的过程"><a href="#封装Vue组件的过程" class="headerlink" title="封装Vue组件的过程"></a>封装Vue组件的过程</h3><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p>
<ul>
<li>分析需求：确定业务需求，把页面中可以复用的结构，样式以及功能，单独抽离成一个组件，实现复用</li>
<li>具体步骤：Vue.component或者在new Vue配置项components中，定义组件名，可以在props中接受给组件传的参数和值，子组件修改好数据后，想把数据传递给父组件。可以采用$emit方法</li>
</ul>
<h3 id="Vue组件如何进行传值"><a href="#Vue组件如何进行传值" class="headerlink" title="Vue组件如何进行传值"></a>Vue组件如何进行传值</h3><p>父向子：props定义变量-&gt;父在使用组件用属性给props变量传值</p>
<p>子向父：$emit触发父事件-&gt;父在使用组件用@自定义事件名=父的方(子把值带出来)</p>
<h3 id="Vue组件data为什么必须是函数"><a href="#Vue组件data为什么必须是函数" class="headerlink" title="Vue组件data为什么必须是函数"></a>Vue组件data为什么必须是函数</h3><p>每个组件都是Vue的实例，为了独立作用域，不让变量污染别人的变量</p>
<h3 id="Vue组件命名规范"><a href="#Vue组件命名规范" class="headerlink" title="Vue组件命名规范"></a>Vue组件命名规范</h3><p>给组件命名有两种方式(在Vue.Component/components时)，一种是使用链式命名”my-component”，一种是使用大驼峰命名”MyCompopent”</p>
<p>因为要遵循W3C规范中的自定义组件名(字母全小写且必须包含一个连字符),避免和当前以及未来的HTML元素相冲突</p>
<h3 id="vue生命周期总共分为几个阶段"><a href="#vue生命周期总共分为几个阶段" class="headerlink" title="vue生命周期总共分为几个阶段"></a>vue生命周期总共分为几个阶段</h3><p>Vue实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom-&gt;渲染、更新-&gt;渲染、卸载等一些列过程，我们称这是Vue的生命周期。</p>
<ol>
<li>beforeCreate<ul>
<li>在实例初始化之后，数据观测(data observer)和 event/watcher事件配置之前被调用</li>
</ul>
</li>
<li>created<ul>
<li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测(data obserer),属性和方法的运算，event/watcher事件回调。然而，挂载阶段还没开始，$el属性目前不可见</li>
</ul>
</li>
<li>beforeMount<ul>
<li>在挂载开始之前被调用，相关的render函数首次被调用</li>
</ul>
</li>
<li>mounted<ul>
<li>el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。如果root实例挂载一个文档内元素，当mounted被调用时，vm.$el也在文档内。</li>
</ul>
</li>
<li>beforeUpdate<ul>
<li>数据更新时调用，发生在虚拟DOM打补丁之前。这里更适合更新之前访问现有的DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</li>
</ul>
</li>
<li>updated<ul>
<li>由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子</li>
</ul>
</li>
<li>activated<ul>
<li>keep-alive组件激活时调用。该钩子在服务器渲染期间不被调用。</li>
</ul>
</li>
<li>deactivated<ul>
<li>   keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。</li>
</ul>
</li>
<li>beforeDestroy<ul>
<li>实例销毁之前调用。在这一步，实力仍然完全可用。该钩子在服务器端渲染期间不被调用</li>
</ul>
</li>
<li>destroyed<ul>
<li>Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li>
</ul>
</li>
<li>errorCaptured(2.5.0新增)<ul>
<li>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回false以阻止该错误继续向上传播</li>
</ul>
</li>
</ol>
<h3 id="第一次加载页面会触发哪几个钩子函数"><a href="#第一次加载页面会触发哪几个钩子函数" class="headerlink" title="第一次加载页面会触发哪几个钩子函数"></a>第一次加载页面会触发哪几个钩子函数</h3><p>beforeCreate、created、beforeMount、mounted</p>
<h3 id="Vue的nextTick的原理是什么？"><a href="#Vue的nextTick的原理是什么？" class="headerlink" title="Vue的nextTick的原理是什么？"></a>Vue的nextTick的原理是什么？</h3><p>为什么需要nextTick，Vue是异步修改DOM的并且不鼓励开发者直接接触DOM，但有时候业务需要必须对数据更改–刷新后的DOM作相应的处理，这时候就可以使用Vue.nextTick(callback)这个api 了‘</p>
<p>理解原理前的准备，首先需要知道事件循环中宏任务和微任务这两个概念，常见的宏任务有script, setTimeout, setInterval, setImmediate, I/O, UIrendering 常见的微任务有process.nextTick(Nodejs), Promise.then(),MutationObserver</p>
<p>理解nextTick的原理正是Vue通过异步队列控制DOM更新和nextTick回调函数先后执行的方式。如果大家看过这部分源码，会发现其中做了很多isNative()的判断，因为这里存在兼容性优雅降级的问题。可见Vue开发团队的深思熟虑，对性能的良苦用心。</p>
<h3 id="自定义指令-v-check、v-focus-的方法以及钩子函数，钩子函数的参数？"><a href="#自定义指令-v-check、v-focus-的方法以及钩子函数，钩子函数的参数？" class="headerlink" title="自定义指令(v-check、v-focus)的方法以及钩子函数，钩子函数的参数？"></a>自定义指令(v-check、v-focus)的方法以及钩子函数，钩子函数的参数？</h3><p>全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令：directives</p>
<p>钩子函数：bind(绑定事件触发)、inserted(节点插入的时候触发)、updae(组件内相关更新)</p>
<p>钩子函数参数：el、binding</p>
<h3 id="is特性，主要用在哪些方面？"><a href="#is特性，主要用在哪些方面？" class="headerlink" title="is特性，主要用在哪些方面？"></a>is特性，主要用在哪些方面？</h3><p> 1.动态组件</p>
<p><code>&lt;component :is=&quot;componentName&quot;&gt;&lt;/component&gt;</code></p>
<p>componentName可以是在本页面已经注册的局部组件名和全局组件名，也可以是一个组建的选项对象。当控制componentName改变时就可以动态选择组件</p>
<p> 2.is的用法</p>
<p>有些HTML元素, 诸如<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code>和<code>&lt;select&gt;</code>，对于哪些元素可以出现在其内部是有严格限制的。</p>
<p>而有些HTML元素，诸如<code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code>和<code>&lt;option&gt;</code>只能出现在某些特定元素的内部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;card-list&gt; &lt;/card-list&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>这么写<code>&lt;card-list&gt;&lt;/card-list&gt;</code>会被作为无效的内容提升到外部，并导致最终渲染结果出错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line"> &lt;li :is=&quot;cardList&quot;&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="路由之间是怎么跳转的？有哪些方式"><a href="#路由之间是怎么跳转的？有哪些方式" class="headerlink" title="路由之间是怎么跳转的？有哪些方式"></a>路由之间是怎么跳转的？有哪些方式</h3><ol>
<li><code>&lt;router-link to=&quot;需要跳转到页面的路径&quot;&gt;&lt;/router-link&gt;</code></li>
<li>this.$router.push()跳转到指定url，并在history中添加记录，点击回退返回上一个页面</li>
<li>this.$router.replace()跳转到指定的url，但是不会在history中记录，点击回退回退到上上个页面</li>
<li>this.$router.go(n)向前或者向后跳转n个页面，n可以是正数也可以是负数</li>
</ol>
<h3 id="vue-router怎么配置路由"><a href="#vue-router怎么配置路由" class="headerlink" title="vue-router怎么配置路由"></a>vue-router怎么配置路由</h3><p>在vue中配置路由分为5个步骤</p>
<ol>
<li>引入vue-router.js</li>
<li>配置路由path和组件，在生成路由对象</li>
<li>把路由对象配置到new Vue中的router选项下</li>
<li>页面使用<code>&lt;router-view&gt;&lt;/router-view&gt;</code>承载路由</li>
<li><code>&lt;router-link to=&quot;需要跳转的路径&quot;&gt;&lt;/router-link&gt;</code>设置路由导航(声明式导航/编程式跳转)</li>
</ol>
<h3 id="vue-toouter-的钩子函数有哪些"><a href="#vue-toouter-的钩子函数有哪些" class="headerlink" title="vue-toouter 的钩子函数有哪些"></a>vue-toouter 的钩子函数有哪些</h3><p>vue-router 中的钩子函数主要分为3类</p>
<p>全局钩子函数 beforeEach</p>
<p>​           beforeEach函数有三个参数, 分别为to、from、next</p>
<p>​                to：router即将进入的路由对象</p>
<p>​                from: 当前导航即将离开的路由</p>
<p>​                next: function,进行管道中的一个钩子，如果执行完了，则导航</p>
<p>​                          状态就是confirmed(确认的) 否则为false，终止导航</p>
<p>单独路由独享组件</p>
<p>​          beforeEnter</p>
<p>组件内钩子</p>
<p>​           beforeRouterEnter</p>
<p>​           beforeRouterUpdate</p>
<p>​           beforeRouterLeave</p>
<h3 id="路由传值的方式有哪几种"><a href="#路由传值的方式有哪几种" class="headerlink" title="路由传值的方式有哪几种"></a>路由传值的方式有哪几种</h3><p>Vue-router传参可以分为两大类，分别是编程式导航router.push 和声明式导航 </p>
<ul>
<li><p>router.push</p>
<ul>
<li> 字符串：直接传递路由地址，但是不能传参数</li>
</ul>
<p>​                this.$router.push(“home”)</p>
<ul>
<li><p>对象：</p>
<p> 命名路由 这种方式传递参数，目标页面刷新会报错</p>
<p>​    -name+parmas</p>
<p>​    this.$router.push({path:”news” , params:{userId:123}})</p>
<p>查询参数 和path配对的是query</p>
<p>​    this.$router.push({path:”/news”, query:{userId:123}})</p>
<p>接收参数 this.$route.query</p>
</li>
</ul>
</li>
<li><p>声明式导航</p>
<ul>
<li><p>字符串<code>&lt;router-link to:&quot;news&quot;&gt;&lt;/router-link&gt;</code></p>
</li>
<li><p>命名路由<code>&lt;router-link :to=&quot;&#123;name:&#39;news&#39;,params:&#123;userid:1111&#125;&#125;&gt;&lt;/router-link&quot;&gt;</code></p>
<p>还可以to=”/path/值” 需要提前在路由规则里值/path/:key</p>
<p>查询参数<code>&lt;router-link :to=&quot;&#123;path:&#39;/news&#39;,query:&#123;userId:111&#125;&#125;&gt;&lt;/router-link&gt;&quot;</code></p>
<p>还可以to=”/path?key=value”</p>
</li>
</ul>
</li>
</ul>
<h3 id="怎么定义vue-router的动态路由？怎么获取传来的动态参数"><a href="#怎么定义vue-router的动态路由？怎么获取传来的动态参数" class="headerlink" title="怎么定义vue-router的动态路由？怎么获取传来的动态参数"></a>怎么定义vue-router的动态路由？怎么获取传来的动态参数</h3><p>动态路由指的是path路径上传值，前提需要路由规则了提前配置/path/:key名，可以写多个，用/隔开，获取使用$route.params.key名来提取对应路径传过来的值</p>
<h3 id="Vue的路由实现模式-hash模式和history模式"><a href="#Vue的路由实现模式-hash模式和history模式" class="headerlink" title="Vue的路由实现模式: hash模式和history模式"></a>Vue的路由实现模式: hash模式和history模式</h3><p>hash模式: 在浏览器中符号#，#以及#后面的字符称之为hash，用window.location.hash读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面</p>
<p>history模式：history采用HTML5的新特信；且提供了两个新方法：pushState()，replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更</p>
<h3 id="路由配置项常用的属性及作用"><a href="#路由配置项常用的属性及作用" class="headerlink" title="路由配置项常用的属性及作用"></a>路由配置项常用的属性及作用</h3><p>路由配置参数：</p>
<ul>
<li>path:跳转路径</li>
<li>component:路径相对于的组件</li>
<li>name:命名路由</li>
<li>children:子路由的配置参数(路由嵌套)</li>
<li>props:路由解耦</li>
<li>redirect:重定向路由</li>
</ul>
<h3 id="编程式导航使用的方法以及常用的方法"><a href="#编程式导航使用的方法以及常用的方法" class="headerlink" title="编程式导航使用的方法以及常用的方法"></a>编程式导航使用的方法以及常用的方法</h3><p>路由跳转: this.$router.push()</p>
<p>路由替换: this.$router.replace()</p>
<p>后退: this.$router.back()</p>
<p>前进: this.$router.forward()</p>
<h3 id="Vue如何去除URL中的"><a href="#Vue如何去除URL中的" class="headerlink" title="Vue如何去除URL中的#"></a>Vue如何去除URL中的#</h3><p>vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 URL 会自带 “#”。如果不想使用 “#”， 可以使用 vue-router 的另一种模式 history：new Router ({ mode : ‘history’, routes: [ ]})</p>
<p>​    需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 “404” 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 “index.html” 页面。</p>
<h3 id="router和-route的区别"><a href="#router和-route的区别" class="headerlink" title="$router和$route的区别"></a>$router和$route的区别</h3><p>$route是路由信息对象，包括‘path，hash，query，fullPath，  matched，name’等路由信息参数；<br>        $router是路由实例对象，包括了路由的跳转方法，实例对象等</p>
<h3 id="跟keep-alive有关的生命周期是哪些"><a href="#跟keep-alive有关的生命周期是哪些" class="headerlink" title="跟keep-alive有关的生命周期是哪些"></a>跟keep-alive有关的生命周期是哪些</h3><ol>
<li><p>前言：在开发Vue项目的时候，大部分组件是没必要多次渲染的，所以Vue提供了一个内置组件keep-alive来缓存组件内部状态，避免重新渲染</p>
</li>
<li><p>生命周期函数：再被keep-alive包含的组件/路由中，会多出两个生命周期钩子:activated 与 deactivated</p>
<ul>
<li>activated钩子：在组件第一次渲染时会被调用，之后在每次缓存组件被激活时调用<ul>
<li>activated钩子调用时机：第一次进入缓存路由/组件，在mounted后面，beforeRouteEnter守卫传给next的回调函数之前调用，并且因为组件被缓存了，再次进入缓存路由/组件时，不会触发这些钩子函数，beforeCreate created beforeMount mounted 都不会触发</li>
</ul>
</li>
<li>deactivated钩子：组件被停用时调用<ul>
<li>deactivated钩子调用时机：使用keep-alive就不会调用beforeDestroy(组件销毁前钩子)和destroyed(组件销毁)，因为组件没被销毁，被缓存起来了，这个钩子可以看做beforeDestroy的替代，如果你缓存了组件，要在组件被销毁的时候做一些事情，可以放在这个钩子里，组件内的离开当前路由钩子beforeRouteLeave=&gt; 路由前置守卫 beforeEach =&gt;全局后置钩子afterEach =&gt; deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="Vue的组件"><a href="#Vue的组件" class="headerlink" title="Vue的组件"></a>Vue的组件</h3><p>问：组件是什么？</p>
<p>答：组件就是每一个 Vue 实例，是由标签，样式，js组成的</p>
<p>vue是单向数据流</p>
<h3 id="Vue的组件通信"><a href="#Vue的组件通信" class="headerlink" title="Vue的组件通信"></a>Vue的组件通信</h3><p>Vue是单向的，只能父传子。</p>
<h1 id="错误记录"><a href="#错误记录" class="headerlink" title="错误记录"></a>错误记录</h1><p>没有template</p>
<p>只能有一个根节点</p>
<p><strong>Indicate whether to send a cookie in a cross-site request by specifying its SameSite attribute</strong></p>
<p>不显示的报错，是由于谷歌浏览器版本更新主要是为了防止CSRF 攻击，屏蔽了第三方cookies</p>
<p>警告信息中讲到一个<code>SameSite</code>属性，是为了限制第三方的cookies，有三个属性设置<code>Strict、Lax、None</code></p>
<p> <strong>Error in directive foc inserted hook: “TypeError: Cannot read properties of undefined (reading ‘$nextTick’)”</strong></p>
<p>这个位置不能使用$nextTick</p>
<h5 id="vue的一些问题"><a href="#vue的一些问题" class="headerlink" title="vue的一些问题"></a>vue的一些问题</h5><p>1、第一个是给对象添加属性的时候，直接通过给data里面的对象添加属性然后赋值，新添加的属性不是响应式的</p>
<p>​    【解决办法】通过Vue.set(对象，属性，值)这种方式就可以达到，对象新添加的属性是响应式的</p>
<p>2、 在created操作dom的时候，是报错的，获取不到dom，这个时候实例vue实例没有挂载</p>
<p>​    【解决办法】通过：Vue.nextTick(回调函数进行获取)</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol>
<li>Vue是单向数据流，不能修改props数据，但是Vue限制的是不允许<code>this.list=xxx</code>修改，在学习v-for时也提过：<code>list[0]=1</code>不会触发页面刷新。但是<code>list[index].name=&#39;1&#39;可以修改</code>，因为修改的是属性。</li>
<li>只有变量才有类型 </li>
</ol>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>只要让用户体验不够好我们的代码就可以足够简洁</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>抢银行差点钱买装备</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.JPG" alt="小陈 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.JPG" alt="小陈 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%B0%E5%BD%95%E6%AF%8F%E5%A4%A9%E5%AD%A6%E4%B9%A0%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" rel="tag"># 记录每天学习时的一些问题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/13/hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" rel="prev" title="hexo_搭建博客">
      <i class="fa fa-chevron-left"></i> hexo_搭建博客
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/28/Vue%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AF%BC%E5%85%A5%E6%96%B9%E6%B3%95/" rel="next" title="Vue公共组件一次性全局注册方法">
      Vue公共组件一次性全局注册方法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">学习记录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Ewebpack"><span class="nav-number">1.1.</span> <span class="nav-text">关于webpack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#webpack%E7%9A%84%E4%BC%98%E7%82%B9%E6%9C%89%E5%95%A5"><span class="nav-number">1.1.1.</span> <span class="nav-text">webpack的优点有啥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">webpack的构建流程是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-webpack-%E7%9A%84%E7%83%AD%E6%9B%B4%E6%96%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.1.3.</span> <span class="nav-text">说一下 webpack 的热更新原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#webpack%E4%B8%8Egrunt%E3%80%81gulp%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-number">1.1.4.</span> <span class="nav-text">webpack与grunt、gulp的不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Loader%E5%92%8CPlugin%E7%9A%84%E4%B8%8D%E7%94%A8"><span class="nav-number">1.1.5.</span> <span class="nav-text">Loader和Plugin的不用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EVue"><span class="nav-number">1.2.</span> <span class="nav-text">关于Vue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BC%98%E5%8A%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">Vue的最大优势是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E5%92%8CjQuery%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">Vue和jQuery的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVVM%E5%92%8CMVC%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.3.</span> <span class="nav-text">MVVM和MVC区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue2-x%E5%85%BC%E5%AE%B9IE%E5%93%AA%E4%BA%9B%E7%89%88%E6%9C%AC"><span class="nav-number">1.2.4.</span> <span class="nav-text">Vue2.x兼容IE哪些版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9Vue%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.2.5.</span> <span class="nav-text">对Vue渐进式的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%81%BF%E5%85%8Dv-for%E5%92%8Cv-if%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.6.</span> <span class="nav-text">为什么避免v-for和v-if在一起使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E4%B8%AD-key%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="nav-number">1.2.7.</span> <span class="nav-text">Vue中:key作用，为什么不能用索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%9C%89%E6%97%B6%E5%80%99v-for%E4%B8%8D%E6%B8%B2%E6%9F%93"><span class="nav-number">1.2.8.</span> <span class="nav-text">数据更新有时候v-for不渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85Vue%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.9.</span> <span class="nav-text">封装Vue组件的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%A0%E5%80%BC"><span class="nav-number">1.2.10.</span> <span class="nav-text">Vue组件如何进行传值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E7%BB%84%E4%BB%B6data%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.11.</span> <span class="nav-text">Vue组件data为什么必须是函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E7%BB%84%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.12.</span> <span class="nav-text">Vue组件命名规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E5%85%B1%E5%88%86%E4%B8%BA%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">1.2.13.</span> <span class="nav-text">vue生命周期总共分为几个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8A%A0%E8%BD%BD%E9%A1%B5%E9%9D%A2%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%93%AA%E5%87%A0%E4%B8%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.14.</span> <span class="nav-text">第一次加载页面会触发哪几个钩子函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E7%9A%84nextTick%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.2.15.</span> <span class="nav-text">Vue的nextTick的原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4-v-check%E3%80%81v-focus-%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%EF%BC%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="nav-number">1.2.16.</span> <span class="nav-text">自定义指令(v-check、v-focus)的方法以及钩子函数，钩子函数的参数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#is%E7%89%B9%E6%80%A7%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%94%A8%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%EF%BC%9F"><span class="nav-number">1.2.17.</span> <span class="nav-text">is特性，主要用在哪些方面？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%B3%E8%BD%AC%E7%9A%84%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F"><span class="nav-number">1.2.18.</span> <span class="nav-text">路由之间是怎么跳转的？有哪些方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-router%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1"><span class="nav-number">1.2.19.</span> <span class="nav-text">vue-router怎么配置路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vue-toouter-%E7%9A%84%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">1.2.20.</span> <span class="nav-text">vue-toouter 的钩子函数有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="nav-number">1.2.21.</span> <span class="nav-text">路由传值的方式有哪几种</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89vue-router%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%9F%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BC%A0%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="nav-number">1.2.22.</span> <span class="nav-text">怎么定义vue-router的动态路由？怎么获取传来的动态参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F-hash%E6%A8%A1%E5%BC%8F%E5%92%8Chistory%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.23.</span> <span class="nav-text">Vue的路由实现模式: hash模式和history模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E9%A1%B9%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.24.</span> <span class="nav-text">路由配置项常用的属性及作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.25.</span> <span class="nav-text">编程式导航使用的方法以及常用的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E5%A6%82%E4%BD%95%E5%8E%BB%E9%99%A4URL%E4%B8%AD%E7%9A%84"><span class="nav-number">1.2.26.</span> <span class="nav-text">Vue如何去除URL中的#</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#router%E5%92%8C-route%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.27.</span> <span class="nav-text">$router和$route的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%9Fkeep-alive%E6%9C%89%E5%85%B3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E5%93%AA%E4%BA%9B"><span class="nav-number">1.2.28.</span> <span class="nav-text">跟keep-alive有关的生命周期是哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-number">1.2.29.</span> <span class="nav-text">Vue的组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Vue%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">1.2.30.</span> <span class="nav-text">Vue的组件通信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95"><span class="nav-number">2.</span> <span class="nav-text">错误记录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#vue%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-number">2.0.0.0.1.</span> <span class="nav-text">vue的一些问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PS"><span class="nav-number">4.</span> <span class="nav-text">PS</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">小陈</p>
  <div class="site-description" itemprop="description">Study Record</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小陈</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
